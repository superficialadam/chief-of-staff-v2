#!/usr/bin/env ruby
# bin/ai - HTTP client for Chief of Staff AI server

require "net/http"
require "json"
require "readline"
require "io/console"
require "uri"
require "optparse"

# Try to load pastel for colors if available
begin
  require "pastel"
  require "zlib"
  
  # Inline console colors module (standalone version)
  module ConsoleColors
    PALETTE = %i[bright_magenta bright_blue bright_green bright_yellow cyan].freeze
    module_function

    def pastel
      @pastel ||= Pastel.new(enabled: $stdout.tty?)
    end

    def color_for(name)
      PALETTE[Zlib.crc32(name.to_s) % PALETTE.size]
    end

    def colored_badge(name)
      color = color_for(name)
      pastel.on_black.public_send(color).detach.(" #{name.upcase} ")
    end

    def dim(s) = pastel.dim(s)
  end
  
  COLORS_AVAILABLE = true
rescue LoadError
  COLORS_AVAILABLE = false
  
  # Fallback when pastel is not available
  module ConsoleColors
    module_function
    def colored_badge(name) = "[#{name.upcase}]"
    def dim(s) = s
  end
end

# Parse command line options
options = {
  host: "localhost",
  port: 3000,
  ssl: false
}

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  
  opts.on("-h", "--host HOST", "Rails server host (default: localhost)") do |h|
    options[:host] = h
  end
  
  opts.on("-p", "--port PORT", Integer, "Rails server port (default: 3000)") do |p|
    options[:port] = p
  end
  
  opts.on("-s", "--ssl", "Use HTTPS instead of HTTP") do
    options[:ssl] = true
  end
  
  opts.on("--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

# Build base URL
protocol = options[:ssl] ? "https" : "http"
base_url = "#{protocol}://#{options[:host]}:#{options[:port]}"

# Check server health
def check_server_health(base_url)
  uri = URI.parse("#{base_url}/ai/health")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = uri.scheme == "https"
  http.open_timeout = 10
  http.read_timeout = 15
  
  response = http.get(uri.path)
  # Accept any HTTP response as indication server is running
  # Even 500 errors mean the server is up but may have internal issues
  !response.nil? && response.code.to_i > 0
rescue => e
  false
end

# Send message to server with streaming support
def send_message_stream(base_url, message)
  uri = URI.parse("#{base_url}/ai/stream")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = uri.scheme == "https"
  http.read_timeout = 120 # Allow longer timeout for AI processing
  
  request = Net::HTTP::Post.new(uri.path)
  request["Content-Type"] = "application/json"
  request["Accept"] = "text/event-stream"
  request.body = JSON.generate({ message: message })
  
  result = nil
  processing_shown = false
  
  http.request(request) do |response|
    if response.code != "200"
      error_data = JSON.parse(response.read_body) rescue { "error" => response.read_body }
      raise "Server error (#{response.code}): #{error_data["error"]}"
    end
    
    buffer = ""
    response.read_body do |chunk|
      buffer += chunk
      
      # Process complete SSE messages
      while buffer.include?("\n\n")
        event_data = buffer.slice!(0..buffer.index("\n\n")+1)
        
        # Parse SSE event
        if event_data =~ /event:\s*(\w+)\ndata:\s*(.+)\n/
          event_type = $1
          event_json = $2
          
          begin
            data = JSON.parse(event_json)
            
            case event_type
            when "start"
              # Show processing indicator
              unless processing_shown
                print ConsoleColors.dim("Processing")
                processing_shown = true
              end
              $stdout.flush
            when "iteration"
              # Show iteration progress
              print ConsoleColors.dim(" [#{data["number"]}/#{data["max"]}]")
              $stdout.flush
            when "tool_start"
              # Show tool execution
              print ConsoleColors.dim(" #{data["name"]}")
              $stdout.flush
            when "tool_complete"
              # Show tool completion status
              if data["success"]
                print ConsoleColors.dim("✓")
              else
                print ConsoleColors.dim("✗")
              end
              $stdout.flush
            when "complete"
              # Clear processing indicator and return result
              puts "" if processing_shown
              result = data
              break
            when "error"
              puts "" if processing_shown
              raise "Server error: #{data["error"]}"
            end
          rescue JSON::ParserError
            # Ignore malformed events
          end
        end
      end
      
      break if result
    end
  end
  
  result
end

# Legacy non-streaming send (fallback)
def send_message(base_url, message)
  uri = URI.parse("#{base_url}/ai/chat")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = uri.scheme == "https"
  http.read_timeout = 120 # Allow longer timeout for AI processing
  
  request = Net::HTTP::Post.new(uri.path)
  request["Content-Type"] = "application/json"
  request.body = JSON.generate({ message: message })
  
  response = http.request(request)
  
  if response.code == "200"
    JSON.parse(response.body)
  else
    error_data = JSON.parse(response.body) rescue { "error" => response.body }
    raise "Server error (#{response.code}): #{error_data["error"]}"
  end
end

# Main REPL loop
puts ConsoleColors.dim("Chief of Staff AI Client — Ctrl+C to quit")
puts ConsoleColors.dim("Connecting to #{base_url}...")

# Check if server is running
if check_server_health(base_url)
  puts ConsoleColors.dim("✓ Connected to server")
else
  puts ConsoleColors.dim("✗ Cannot connect to server at #{base_url}")
  puts ConsoleColors.dim("Make sure the Rails server is running: rails s")
  exit 1
end

puts ""

# REPL loop
loop do
  begin
    input = Readline.readline("> ", true)
    
    # Handle empty input or Ctrl+D
    if input.nil? || input.strip.empty?
      next if input&.strip&.empty?
      break if input.nil?
    end
    
    # Special commands
    case input.strip.downcase
    when "exit", "quit", "q"
      puts ConsoleColors.dim("Goodbye!")
      break
    when "health"
      puts ConsoleColors.dim("Checking server health...")
      if check_server_health(base_url)
        puts ConsoleColors.dim("✓ Server is healthy")
      else
        puts ConsoleColors.dim("✗ Server is not responding")
      end
      next
    when "help", "?"
      puts ConsoleColors.dim("Commands:")
      puts ConsoleColors.dim("  exit, quit, q - Exit the REPL")
      puts ConsoleColors.dim("  health        - Check server health")
      puts ConsoleColors.dim("  help, ?       - Show this help")
      puts ConsoleColors.dim("")
      puts ConsoleColors.dim("Or type any message to chat with the AI assistant")
      next
    end
    
    # Show immediate processing indicator
    print ConsoleColors.dim("Processing...")
    $stdout.flush
    
    # Send message to server
    result = send_message(base_url, input)
    
    # Clear processing indicator
    print "\r" + " " * 20 + "\r"  # Clear the line
    
    # Display response
    agent_name = result["agent"] || "unknown"
    agent_text = result["text"] || result["error"] || "No response"
    
    label = ConsoleColors.colored_badge(agent_name)
    puts "#{label} #{agent_text}"
    
  rescue Interrupt
    puts "\n" + ConsoleColors.dim("Exiting...")
    exit
  rescue Errno::ECONNREFUSED
    puts ConsoleColors.dim("✗ Connection refused. Is the Rails server running?")
    puts ConsoleColors.dim("Start it with: rails s")
  rescue Errno::EPIPE, EOFError
    puts ConsoleColors.dim("✗ Lost connection to server")
  rescue => e
    puts ConsoleColors.dim("Error: #{e.message}")
  end
end